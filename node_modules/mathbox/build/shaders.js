module.exports = {"arrow.position": "uniform float worldUnit;\r\nuniform float lineDepth;\r\nuniform float lineWidth;\r\nuniform float focusDepth;\r\n\r\nuniform vec4 geometryClip;\r\nuniform float arrowSize;\r\nuniform float arrowSpace;\r\n\r\nattribute vec4 position4;\r\nattribute vec3 arrow;\r\nattribute vec2 attach;\r\n\r\n// External\r\nvec3 getPosition(vec4 xyzw, float canonical);\r\n\r\nvoid getArrowGeometry(vec4 xyzw, float near, float far, out vec3 left, out vec3 right, out vec3 start) {\r\n  right = getPosition(xyzw, 1.0);\r\n  left  = getPosition(vec4(near, xyzw.yzw), 0.0);\r\n  start = getPosition(vec4(far, xyzw.yzw), 0.0);\r\n}\r\n\r\nmat4 getArrowMatrix(vec3 left, vec3 right, vec3 start) {\r\n\r\n  float depth = focusDepth;\r\n  if (lineDepth < 1.0) {\r\n    // Depth blending\r\n    float z = max(0.00001, -right.z);\r\n    depth = mix(z, focusDepth, lineDepth);\r\n  }\r\n    \r\n  vec3 diff = left - right;\r\n  float l = length(diff);\r\n  if (l == 0.0) {\r\n    return mat4(1.0, 0.0, 0.0, 0.0,\r\n                0.0, 1.0, 0.0, 0.0,\r\n                0.0, 0.0, 1.0, 0.0,\r\n                0.0, 0.0, 0.0, 1.0);\r\n  }\r\n\r\n  // Construct TBN matrix around shaft\r\n  vec3 t = normalize(diff);\r\n  vec3 n = normalize(cross(t, t.yzx + vec3(.1, .2, .3)));\r\n  vec3 b = cross(n, t);\r\n  \r\n  // Shrink arrows when vector gets too small\r\n  // Approach linear scaling with cubic ease the smaller we get\r\n  float size = arrowSize * lineWidth * worldUnit * depth * 1.25;\r\n  diff = right - start;\r\n  l = length(diff) * arrowSpace;\r\n  float mini = clamp(1.0 - l / size * .333, 0.0, 1.0);\r\n  float scale = 1.0 - mini * mini * mini;\r\n  float range = size * scale;\r\n  \r\n  // Size to 2.5:1 ratio\r\n  float rangeNB = range / 2.5;\r\n\r\n  // Anchor at end position\r\n  return mat4(vec4(n * rangeNB,  0),\r\n              vec4(b * rangeNB,  0),\r\n              vec4(t * range, 0),\r\n              vec4(right,  1.0));\r\n}\r\n\r\nvec3 getArrowPosition() {\r\n  vec3 left, right, start;\r\n  \r\n  vec4 p = min(geometryClip, position4);\r\n  \r\n  getArrowGeometry(p, attach.x, attach.y, left, right, start);\r\n  mat4 matrix = getArrowMatrix(left, right, start);\r\n  return (matrix * vec4(arrow.xyz, 1.0)).xyz;\r\n\r\n}\r\n",
"axis.position": "uniform vec4 axisStep;\r\nuniform vec4 axisPosition;\r\n\r\nvec4 getAxisPosition(vec4 xyzw, inout vec4 stpq) {\r\n  return axisStep * xyzw.x + axisPosition;\r\n}\r\n",
"cartesian.position": "uniform mat4 viewMatrix;\r\n\r\nvec4 getCartesianPosition(vec4 position, inout vec4 stpq) {\r\n  return viewMatrix * vec4(position.xyz, 1.0);\r\n}\r\n",
"cartesian4.position": "uniform vec4 basisScale;\r\nuniform vec4 basisOffset;\r\nuniform vec4 viewScale;\r\nuniform vec4 viewOffset;\r\n\r\nvec4 getCartesian4Position(vec4 position, inout vec4 stpq) {\r\n  return position * basisScale + basisOffset;\r\n}\r\n",
"clamp.position": "uniform vec4 clampLimit;\r\n\r\nvec4 getClampXYZW(vec4 xyzw) {\r\n  return clamp(xyzw, vec4(0.0), clampLimit);\r\n}\r\n",
"color.opaque": "vec4 opaqueColor(vec4 color) {\r\n  return vec4(color.rgb, 1.0);\r\n}\r\n",
"face.position": "uniform vec4 geometryClip;\r\nattribute vec4 position4;\r\n\r\n// External\r\nvec3 getPosition(vec4 xyzw, float canonical);\r\n\r\nvec3 getFacePosition() {\r\n  vec4 p = min(geometryClip, position4);\r\n  return getPosition(p, 1.0);\r\n}\r\n",
"face.position.normal": "attribute vec4 position4;\r\n\r\n// External\r\nvec3 getPosition(vec4 xyzw, float canonical);\r\n\r\nvarying vec3 vNormal;\r\nvarying vec3 vLight;\r\nvarying vec3 vPosition;\r\n\r\nvoid getFaceGeometry(vec4 xyzw, out vec3 pos, out vec3 normal) {\r\n  vec3 a, b, c;\r\n\r\n  a   = getPosition(vec4(xyzw.xyz, 0.0), 0.0);\r\n  b   = getPosition(vec4(xyzw.xyz, 1.0), 0.0);\r\n  c   = getPosition(vec4(xyzw.xyz, 2.0), 0.0);\r\n\r\n  pos = getPosition(xyzw, 1.0);\r\n  normal = normalize(cross(c - a, b - a));\r\n}\r\n\r\nvec3 getFacePositionNormal() {\r\n  vec3 center, normal;\r\n\r\n  getFaceGeometry(position4, center, normal);\r\n  vNormal   = normal;\r\n  vLight    = normalize((viewMatrix * vec4(1.0, 2.0, 2.0, 0.0)).xyz);\r\n  vPosition = -center;\r\n\r\n  return center;\r\n}\r\n",
"float.encode": "/*\r\nFloat encoding technique by\r\nCarlos Scheidegger\r\nhttps://github.com/cscheid/lux/blob/master/src/shade/bits/encode_float.js\r\n\r\nConversion to GLSL by:\r\nhttp://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js\r\n*/\r\n\r\nfloat shift_right(float v, float amt) { \r\n  v = floor(v) + 0.5; \r\n  return floor(v / exp2(amt)); \r\n}\r\n\r\nfloat shift_left(float v, float amt) { \r\n  return floor(v * exp2(amt) + 0.5); \r\n}\r\n\r\nfloat mask_last(float v, float bits) { \r\n  return mod(v, shift_left(1.0, bits)); \r\n}\r\n\r\nfloat extract_bits(float num, float from, float to) { \r\n  from = floor(from + 0.5); to = floor(to + 0.5); \r\n  return mask_last(shift_right(num, from), to - from); \r\n}\r\n\r\nvec4 encode_float(float val) { \r\n  if (val == 0.0) return vec4(0, 0, 0, 0); \r\n  float valuesign = val > 0.0 ? 0.0 : 1.0; \r\n  val = abs(val); \r\n  float exponent = floor(log2(val)); \r\n  float biased_exponent = exponent + 127.0; \r\n  float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0; \r\n  float t = biased_exponent / 2.0; \r\n  float last_bit_of_biased_exponent = fract(t) * 2.0; \r\n  float remaining_bits_of_biased_exponent = floor(t); \r\n  float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0; \r\n  float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0; \r\n  float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0; \r\n  float byte1 = (valuesign * 128.0 + remaining_bits_of_biased_exponent) / 255.0; \r\n  return vec4(byte4, byte3, byte2, byte1); \r\n}\r\n",
"float.index.pack": "uniform vec4 indexModulus;\r\n\r\nvec4 getSample(vec4 xyzw);\r\nvec4 getIndex(vec4 xyzw);\r\n\r\nvec4 floatPackIndex(vec4 xyzw) {\r\n  vec4 value = getSample(xyzw);\r\n  vec4 index = getIndex(xyzw);\r\n\r\n  vec4 offset = floor(index + .5) * indexModulus;\r\n  vec2 sum2 = offset.xy + offset.zw;\r\n  float sum = sum2.x + sum2.y;\r\n  return vec4(value.xyz, sum);\r\n}",
"float.stretch": "vec4 getSample(vec4 xyzw);\r\n\r\nfloat floatStretch(vec4 xyzw, float channelIndex) {\r\n  vec4 sample = getSample(xyzw);\r\n  vec2 xy = channelIndex > 1.5 ? sample.zw : sample.xy;\r\n  return mod(channelIndex, 2.0) > .5 ? xy.y : xy.x;\r\n}",
"fragment.clip.dashed": "varying float vClipStrokeWidth;\r\nvarying float vClipStrokeIndex;\r\nvarying vec3  vClipStrokeEven;\r\nvarying vec3  vClipStrokeOdd;\r\nvarying vec3  vClipStrokePosition;\r\n\r\nvoid clipStrokeFragment() {\r\n  bool odd = mod(vClipStrokeIndex, 2.0) >= 1.0;\r\n\r\n  vec3 tangent;\r\n  if (odd) {\r\n    tangent = vClipStrokeOdd;\r\n  }\r\n  else {\r\n    tangent = vClipStrokeEven;\r\n  }\r\n\r\n  float travel = dot(vClipStrokePosition, normalize(tangent)) / vClipStrokeWidth;\r\n  if (mod(travel, 16.0) > 8.0) {\r\n    discard;\r\n  }\r\n}\r\n",
"fragment.clip.dotted": "varying float vClipStrokeWidth;\r\nvarying float vClipStrokeIndex;\r\nvarying vec3  vClipStrokeEven;\r\nvarying vec3  vClipStrokeOdd;\r\nvarying vec3  vClipStrokePosition;\r\n\r\nvoid clipStrokeFragment() {\r\n  bool odd = mod(vClipStrokeIndex, 2.0) >= 1.0;\r\n\r\n  vec3 tangent;\r\n  if (odd) {\r\n    tangent = vClipStrokeOdd;\r\n  }\r\n  else {\r\n    tangent = vClipStrokeEven;\r\n  }\r\n\r\n  float travel = dot(vClipStrokePosition, normalize(tangent)) / vClipStrokeWidth;\r\n  if (mod(travel, 4.0) > 2.0) {\r\n    discard;\r\n  }\r\n}\r\n",
"fragment.clip.ends": "varying vec2 vClipEnds;\r\n\r\nvoid clipEndsFragment() {\r\n  if (vClipEnds.x < 0.0 || vClipEnds.y < 0.0) discard;\r\n}\r\n",
"fragment.clip.proximity": "varying float vClipProximity;\r\n\r\nvoid clipProximityFragment() {\r\n  if (vClipProximity >= 0.5) discard;\r\n}",
"fragment.color": "void setFragmentColor(vec4 color) {\r\n  gl_FragColor = color;\r\n}",
"fragment.map.rgba": "vec4 fragmentRGBA(vec4 rgba, vec4 stpq) {\r\n  return rgba;\r\n}",
"fragment.solid": "void setFragmentColor(vec4 color) {\r\n  if (color.a < 1.0) discard;\r\n  gl_FragColor = color;\r\n}",
"fragment.transparent": "void setFragmentColor(vec4 color) {\r\n  if (color.a >= 1.0) discard;\r\n  gl_FragColor = color;\r\n}",
"grid.position": "uniform vec4 gridPosition;\r\nuniform vec4 gridStep;\r\nuniform vec4 gridAxis;\r\n\r\nvec4 sampleData(vec2 xy);\r\n\r\nvec4 getGridPosition(vec4 xyzw) {\r\n  vec4 onAxis  = gridAxis * sampleData(vec2(xyzw.y, 0.0)).x;\r\n  vec4 offAxis = gridStep * xyzw.x + gridPosition;\r\n  return onAxis + offAxis;\r\n}\r\n",
"grow.position": "uniform float growScale;\r\nuniform vec4  growMask;\r\nuniform vec4  growAnchor;\r\n\r\nvec4 getSample(vec4 xyzw);\r\n\r\nvec4 getGrowSample(vec4 xyzw) {\r\n  vec4 anchor = xyzw * growMask + growAnchor;\r\n\r\n  vec4 position = getSample(xyzw);\r\n  vec4 center = getSample(anchor);\r\n\r\n  return mix(center, position, growScale);\r\n}",
"join.position": "uniform float joinStride;\r\nuniform float joinStrideInv;\r\n\r\nfloat getIndex(vec4 xyzw);\r\nvec4 getRest(vec4 xyzw);\r\nvec4 injectIndices(float a, float b);\r\n\r\nvec4 getJoinXYZW(vec4 xyzw) {\r\n\r\n  float a = getIndex(xyzw);\r\n  float b = a * joinStrideInv;\r\n\r\n  float integer  = floor(b);\r\n  float fraction = b - integer;\r\n  \r\n  return injectIndices(fraction * joinStride, integer) + getRest(xyzw);\r\n}\r\n",
"label.alpha": "varying float vPixelSize;\r\n\r\nvec4 getLabelAlphaColor(vec4 color, vec4 sample) {\r\n  float mask = clamp(sample.r * 1000.0, 0.0, 1.0);\r\n  float alpha = (sample.r - .5) * vPixelSize + .5;\r\n  float a = mask * alpha * color.a;\r\n  if (a <= 0.0) discard;\r\n  return vec4(color.xyz, a);\r\n}\r\n",
"label.map": "vec2 mapUV(vec4 uvwo, vec4 stpq) {\r\n  return uvwo.xy;\r\n}\r\n",
"label.outline": "uniform float outlineExpand;\r\nuniform float outlineStep;\r\nuniform vec3  outlineColor;\r\n\r\nvarying float vPixelSize;\r\n\r\nconst float PIXEL_STEP = 255.0 / 16.0;\r\n\r\nvec4 getLabelOutlineColor(vec4 color, vec4 sample) {\r\n  float ps = vPixelSize * PIXEL_STEP;\r\n  float os = outlineStep;\r\n\r\n  float sdf = sample.r - .5 + outlineExpand;\r\n  vec2  sdfs = vec2(sdf, sdf + os);\r\n  vec2  alpha = clamp(sdfs * ps + .5, 0.0, 1.0);\r\n\r\n  if (alpha.y <= 0.0) {\r\n    discard;\r\n  }\r\n\r\n  vec3 blend = color.xyz;\r\n  if (alpha.y > alpha.x) {\r\n    blend = sqrt(mix(outlineColor * outlineColor, blend * blend, alpha.x));\r\n  }\r\n  \r\n  return vec4(blend, alpha.y * color.a);\r\n}\r\n",
"layer.position": "uniform vec4 layerScale;\r\nuniform vec4 layerBias;\r\n\r\nvec4 layerPosition(vec4 position, inout vec4 stpq) {\r\n  return layerScale * position + layerBias;\r\n}\r\n",
"lerp.depth": "// External\r\nvec4 sampleData(vec4 xyzw);\r\n\r\nvec4 lerpDepth(vec4 xyzw) {\r\n  float x = xyzw.z;\r\n  float i = floor(x);\r\n  float f = x - i;\r\n    \r\n  vec4 xyzw1 = vec4(xyzw.xy, i, xyzw.w);\r\n  vec4 xyzw2 = vec4(xyzw.xy, i + 1.0, xyzw.w);\r\n  \r\n  vec4 a = sampleData(xyzw1);\r\n  vec4 b = sampleData(xyzw2);\r\n\r\n  return mix(a, b, f);\r\n}\r\n",
"lerp.height": "// External\r\nvec4 sampleData(vec4 xyzw);\r\n\r\nvec4 lerpHeight(vec4 xyzw) {\r\n  float x = xyzw.y;\r\n  float i = floor(x);\r\n  float f = x - i;\r\n    \r\n  vec4 xyzw1 = vec4(xyzw.x, i, xyzw.zw);\r\n  vec4 xyzw2 = vec4(xyzw.x, i + 1.0, xyzw.zw);\r\n  \r\n  vec4 a = sampleData(xyzw1);\r\n  vec4 b = sampleData(xyzw2);\r\n\r\n  return mix(a, b, f);\r\n}\r\n",
"lerp.items": "// External\r\nvec4 sampleData(vec4 xyzw);\r\n\r\nvec4 lerpItems(vec4 xyzw) {\r\n  float x = xyzw.w;\r\n  float i = floor(x);\r\n  float f = x - i;\r\n    \r\n  vec4 xyzw1 = vec4(xyzw.xyz, i);\r\n  vec4 xyzw2 = vec4(xyzw.xyz, i + 1.0);\r\n  \r\n  vec4 a = sampleData(xyzw1);\r\n  vec4 b = sampleData(xyzw2);\r\n\r\n  return mix(a, b, f);\r\n}\r\n",
"lerp.width": "// External\r\nvec4 sampleData(vec4 xyzw);\r\n\r\nvec4 lerpWidth(vec4 xyzw) {\r\n  float x = xyzw.x;\r\n  float i = floor(x);\r\n  float f = x - i;\r\n    \r\n  vec4 xyzw1 = vec4(i, xyzw.yzw);\r\n  vec4 xyzw2 = vec4(i + 1.0, xyzw.yzw);\r\n  \r\n  vec4 a = sampleData(xyzw1);\r\n  vec4 b = sampleData(xyzw2);\r\n\r\n  return mix(a, b, f);\r\n}\r\n",
"line.position": "// Units and calibration\r\nuniform float worldUnit;\r\nuniform float lineWidth;\r\nuniform float lineDepth;\r\nuniform float focusDepth;\r\n\r\n// General data index\r\nuniform vec4 geometryClip;\r\nattribute vec4 position4;\r\n\r\n// (Start/mid/end -1/0/1, top/bottom -1,1) \r\nattribute vec2 line;\r\n\r\n// 0...1 for round or bevel joins\r\n#ifdef LINE_JOIN_DETAIL\r\nattribute float joint;\r\n#else\r\nconst float joint = 0.0;\r\n#endif\r\n\r\n// Knock out excessively long line segments (e.g. for asymtpotes)\r\n#ifdef LINE_PROXIMITY\r\nuniform float lineProximity;\r\nvarying float vClipProximity;\r\n#endif\r\n\r\n// Ghetto line stroking (local only, not global)\r\n#ifdef LINE_STROKE\r\nvarying float vClipStrokeWidth;\r\nvarying float vClipStrokeIndex;\r\nvarying vec3  vClipStrokeEven;\r\nvarying vec3  vClipStrokeOdd;\r\nvarying vec3  vClipStrokePosition;\r\n#endif\r\n\r\n// External\r\nvec3 getPosition(vec4 xyzw, float canonical);\r\n\r\n// Clip line ends for arrows / decoration\r\n#ifdef LINE_CLIP\r\nuniform float clipRange;\r\nuniform vec2  clipStyle;\r\nuniform float clipSpace;\r\n\r\nattribute vec2 strip;\r\n\r\nvarying vec2 vClipEnds;\r\n\r\nvoid clipEnds(vec4 xyzw, vec3 center, vec3 pos) {\r\n\r\n  // Sample end of line strip\r\n  vec4 xyzwE = vec4(strip.y, xyzw.yzw);\r\n  vec3 end   = getPosition(xyzwE, 0.0);\r\n\r\n  // Sample start of line strip\r\n  vec4 xyzwS = vec4(strip.x, xyzw.yzw);\r\n  vec3 start = getPosition(xyzwS, 0.0);\r\n\r\n  // Measure length\r\n  vec3 diff = end - start;\r\n  float l = length(diff) * clipSpace;\r\n\r\n  // Arrow length (=2.5x radius)\r\n  float arrowSize = 1.25 * clipRange * lineWidth * worldUnit;\r\n\r\n  vClipEnds = vec2(1.0);\r\n\r\n  if (clipStyle.y > 0.0) {\r\n    // Depth blend end\r\n    float depth = focusDepth;\r\n    if (lineDepth < 1.0) {\r\n      float z = max(0.00001, -end.z);\r\n      depth = mix(z, focusDepth, lineDepth);\r\n    }\r\n    \r\n    // Absolute arrow length\r\n    float size = arrowSize * depth;\r\n\r\n    // Adjust clip range\r\n    // Approach linear scaling with cubic ease the smaller we get\r\n    float mini = clamp(1.0 - l / size * .333, 0.0, 1.0);\r\n    float scale = 1.0 - mini * mini * mini; \r\n    float invrange = 1.0 / (size * scale);\r\n  \r\n    // Clip end\r\n    diff = normalize(end - center);\r\n    float d = dot(end - pos, diff);\r\n    vClipEnds.x = d * invrange - 1.0;\r\n  }\r\n\r\n  if (clipStyle.x > 0.0) {\r\n    // Depth blend start\r\n    float depth = focusDepth;\r\n    if (lineDepth < 1.0) {\r\n      float z = max(0.00001, -start.z);\r\n      depth = mix(z, focusDepth, lineDepth);\r\n    }\r\n    \r\n    // Absolute arrow length\r\n    float size = arrowSize * depth;\r\n\r\n    // Adjust clip range\r\n    // Approach linear scaling with cubic ease the smaller we get\r\n    float mini = clamp(1.0 - l / size * .333, 0.0, 1.0);\r\n    float scale = 1.0 - mini * mini * mini; \r\n    float invrange = 1.0 / (size * scale);\r\n  \r\n    // Clip start \r\n    diff = normalize(center - start);\r\n    float d = dot(pos - start, diff);\r\n    vClipEnds.y = d * invrange - 1.0;\r\n  }\r\n\r\n\r\n}\r\n#endif\r\n\r\n// Adjust left/center/right to be inside near/far z range\r\nconst float epsilon = 1e-5;\r\nvoid fixCenter(inout vec3 left, inout vec3 center, inout vec3 right) {\r\n  if (center.z >= 0.0) {\r\n    if (left.z < 0.0) {\r\n      float d = (center.z + epsilon) / (center.z - left.z);\r\n      center = mix(center, left, d);\r\n    }\r\n    else if (right.z < 0.0) {\r\n      float d = (center.z + epsilon) / (center.z - right.z);\r\n      center = mix(center, right, d);\r\n    }\r\n  }\r\n\r\n  if (left.z >= 0.0) {\r\n    if (center.z < 0.0) {\r\n      float d = (left.z + epsilon) / (left.z - center.z);\r\n      left = mix(left, center, d);\r\n    }\r\n  }\r\n\r\n  if (right.z >= 0.0) {\r\n    if (center.z < 0.0) {\r\n      float d = (right.z + epsilon) / (right.z - center.z);\r\n      right = mix(right, center, d);\r\n    }\r\n  }\r\n}\r\n\r\n// Sample the source data in an edge-aware manner\r\nvoid getLineGeometry(vec4 xyzw, float edge, out vec3 left, out vec3 center, out vec3 right) {\r\n  vec4 delta = vec4(1.0, 0.0, 0.0, 0.0);\r\n\r\n  center =                 getPosition(xyzw, 1.0);\r\n  left   = (edge > -0.5) ? getPosition(xyzw - delta, 0.0) : center;\r\n  right  = (edge < 0.5)  ? getPosition(xyzw + delta, 0.0) : center;\r\n}\r\n\r\n// Calculate the position for a vertex along the line, including joins\r\nvec3 getLineJoin(float edge, bool odd, vec3 left, vec3 center, vec3 right, float width, float offset, float joint) {\r\n  vec2 join = vec2(1.0, 0.0);\r\n\r\n  fixCenter(left, center, right);\r\n\r\n  vec4 a = vec4(left.xy, right.xy);\r\n  vec4 b = a / vec4(left.zz, right.zz);\r\n\r\n  vec2 l = b.xy;\r\n  vec2 r = b.zw;\r\n  vec2 c = center.xy / center.z;\r\n\r\n  vec4 d = vec4(l, c) - vec4(c, r);\r\n  float l1 = dot(d.xy, d.xy);\r\n  float l2 = dot(d.zw, d.zw);\r\n\r\n  if (l1 + l2 > 0.0) {\r\n    \r\n    if (edge > 0.5 || l2 == 0.0) {\r\n      vec2 nl = normalize(d.xy);\r\n      vec2 tl = vec2(nl.y, -nl.x);\r\n\r\n#ifdef LINE_PROXIMITY\r\n      vClipProximity = 1.0;\r\n#endif\r\n\r\n#ifdef LINE_STROKE\r\n      vClipStrokeEven = vClipStrokeOdd = normalize(left - center);\r\n#endif\r\n      join = tl;\r\n    }\r\n    else if (edge < -0.5 || l1 == 0.0) {\r\n      vec2 nr = normalize(d.zw);\r\n      vec2 tr = vec2(nr.y, -nr.x);\r\n\r\n#ifdef LINE_PROXIMITY\r\n      vClipProximity = 1.0;\r\n#endif\r\n\r\n#ifdef LINE_STROKE\r\n      vClipStrokeEven = vClipStrokeOdd = normalize(center - right);\r\n#endif\r\n      join = tr;\r\n    }\r\n    else {\r\n      // Limit join stretch for tiny segments\r\n      float lmin2 = min(l1, l2) / (width * width);\r\n\r\n      // Hide line segment if ratio of leg lengths exceeds promixity threshold\r\n#ifdef LINE_PROXIMITY\r\n      float lr     = l1 / l2;\r\n      float rl     = l2 / l1;\r\n      float ratio  = max(lr, rl);\r\n      float thresh = lineProximity + 1.0;\r\n      vClipProximity = (ratio > thresh * thresh) ? 1.0 : 0.0;\r\n#endif\r\n\r\n      // Calculate normals/tangents\r\n      vec2 nl = normalize(d.xy);\r\n      vec2 nr = normalize(d.zw);\r\n\r\n      // Calculate tangents\r\n      vec2 tl = vec2(nl.y, -nl.x);\r\n      vec2 tr = vec2(nr.y, -nr.x);\r\n\r\n#ifdef LINE_PROXIMITY\r\n      // Mix tangents according to leg lengths\r\n      vec2 tc = normalize(mix(tl, tr, l1/(l1+l2)));\r\n#else\r\n      // Average tangent\r\n      vec2 tc = normalize(tl + tr);\r\n#endif\r\n    \r\n      // Miter join\r\n      float cosA   = dot(nl, tc);\r\n      float sinA   = max(0.1, abs(dot(tl, tc)));\r\n      float factor = cosA / sinA;\r\n      float scale  = sqrt(1.0 + min(lmin2, factor * factor));\r\n\r\n      // Stroke normals\r\n#ifdef LINE_STROKE\r\n      vec3 stroke1 = normalize(left - center);\r\n      vec3 stroke2 = normalize(center - right);\r\n\r\n      if (odd) {\r\n        vClipStrokeEven = stroke1;\r\n        vClipStrokeOdd  = stroke2;\r\n      }\r\n      else {\r\n        vClipStrokeEven = stroke2;\r\n        vClipStrokeOdd  = stroke1;\r\n      }\r\n#endif\r\n\r\n#ifdef LINE_JOIN_MITER\r\n      // Apply straight up miter\r\n      join = tc * scale;\r\n#endif\r\n\r\n#ifdef LINE_JOIN_ROUND\r\n      // Slerp bevel join into circular arc\r\n      float dotProduct = dot(nl, nr);\r\n      float angle = acos(dotProduct);\r\n      float sinT  = sin(angle);\r\n      join = (sin((1.0 - joint) * angle) * tl + sin(joint * angle) * tr) / sinT;\r\n#endif\r\n\r\n#ifdef LINE_JOIN_BEVEL\r\n      // Direct bevel join between two flat ends\r\n      float dotProduct = dot(nl, nr);\r\n      join = mix(tl, tr, joint);\r\n#endif\r\n\r\n#ifdef LINE_JOIN_DETAIL\r\n      // Check if on inside or outside of joint\r\n      float crossProduct = nl.x * nr.y - nl.y * nr.x;\r\n      if (offset * crossProduct < 0.0) {\r\n        // For near-180-degree bends, correct back to a miter to avoid discontinuities\r\n        float ratio = clamp(-dotProduct * 2.0 - 1.0, 0.0, 1.0);\r\n        // Otherwise collapse the inside vertices into one.\r\n        join = mix(tc * scale, join, ratio * ratio * ratio);\r\n      }\r\n#endif\r\n\r\n    }\r\n    return vec3(join, 0.0);\r\n  }\r\n  else {\r\n    return vec3(0.0);\r\n  }\r\n\r\n}\r\n\r\n// Calculate final line position\r\nvec3 getLinePosition() {\r\n  vec3 left, center, right, join;\r\n\r\n  // left/center/right\r\n  float edge = line.x;\r\n  // up/down\r\n  float offset = line.y;\r\n\r\n  // Clip data\r\n  vec4 p = min(geometryClip, position4);\r\n  edge += max(0.0, position4.x - geometryClip.x);\r\n\r\n  // Get position + adjacent neighbours\r\n  getLineGeometry(p, edge, left, center, right);\r\n\r\n#ifdef LINE_STROKE\r\n  // Set parameters for line stroke fragment shader\r\n  vClipStrokePosition = center;\r\n  vClipStrokeIndex = p.x;\r\n  bool odd = mod(p.x, 2.0) >= 1.0;\r\n#else\r\n  bool odd = true;\r\n#endif\r\n\r\n  // Divide line width up/down\r\n  float width = lineWidth * 0.5;\r\n\r\n  float depth = focusDepth;\r\n  if (lineDepth < 1.0) {\r\n    // Depth blending\r\n    float z = max(0.00001, -center.z);\r\n    depth = mix(z, focusDepth, lineDepth);\r\n  }\r\n  width *= depth;\r\n\r\n  // Convert to world units\r\n  width *= worldUnit;\r\n\r\n  // Calculate line join\r\n  join = getLineJoin(edge, odd, left, center, right, width, offset, joint);\r\n  vec3 pos = center + join * offset * width;\r\n\r\n#ifdef LINE_STROKE\r\n  vClipStrokeWidth = width;\r\n#endif\r\n\r\n#ifdef LINE_CLIP\r\n  clipEnds(p, center, pos);\r\n#endif\r\n\r\n  return pos;\r\n}\r\n",
"map.2d.data": "uniform vec2 dataResolution;\r\nuniform vec2 dataPointer;\r\n\r\nvec2 map2DData(vec2 xy) {\r\n  return (xy + dataPointer) * dataResolution;\r\n}\r\n",
"map.2d.data.wrap": "uniform vec2 dataResolution;\r\nuniform vec2 dataPointer;\r\n\r\nvec2 map2DData(vec2 xy) {\r\n  return fract((xy + dataPointer) * dataResolution);\r\n}\r\n",
"map.xyzw.2dv": "void mapXyzw2DV(vec4 xyzw, out vec2 xy, out float z) {\r\n  xy = xyzw.xy;\r\n  z  = xyzw.z;\r\n}\r\n\r\n",
"map.xyzw.align": "vec4 alignXYZW(vec4 xyzw) {\r\n  return floor(xyzw + .5);\r\n}\r\n\r\n",
"map.xyzw.texture": "uniform float textureItems;\r\nuniform float textureHeight;\r\n\r\nvec2 mapXyzwTexture(vec4 xyzw) {\r\n  \r\n  float x = xyzw.x;\r\n  float y = xyzw.y;\r\n  float z = xyzw.z;\r\n  float i = xyzw.w;\r\n  \r\n  return vec2(i, y) + vec2(x, z) * vec2(textureItems, textureHeight);\r\n}\r\n\r\n",
"mesh.fragment.color": "varying vec4 vColor;\r\n\r\nvec4 getColor() {\r\n  return vColor;\r\n}\r\n",
"mesh.fragment.map": "#ifdef POSITION_STPQ\r\nvarying vec4 vSTPQ;\r\n#endif\r\n#ifdef POSITION_U\r\nvarying float vU;\r\n#endif\r\n#ifdef POSITION_UV\r\nvarying vec2 vUV;\r\n#endif\r\n#ifdef POSITION_UVW\r\nvarying vec3 vUVW;\r\n#endif\r\n#ifdef POSITION_UVWO\r\nvarying vec4 vUVWO;\r\n#endif\r\n\r\nvec4 getSample(vec4 uvwo, vec4 stpq);\r\n\r\nvec4 getMapColor() {\r\n  #ifdef POSITION_STPQ\r\n  vec4 stpq = vSTPQ;\r\n  #else\r\n  vec4 stpq = vec4(0.0);\r\n  #endif\r\n\r\n  #ifdef POSITION_U\r\n  vec4 uvwo = vec4(vU, 0.0, 0.0, 0.0);\r\n  #endif\r\n  #ifdef POSITION_UV\r\n  vec4 uvwo = vec4(vUV, 0.0, 0.0);\r\n  #endif\r\n  #ifdef POSITION_UVW\r\n  vec4 uvwo = vec4(vUVW, 0.0);\r\n  #endif\r\n  #ifdef POSITION_UVWO\r\n  vec4 uvwo = vec4(vUVWO);\r\n  #endif\r\n\r\n  return getSample(uvwo, stpq);\r\n}\r\n",
"mesh.fragment.mask": "varying float vMask;\r\n\r\nfloat ease(float t) {\r\n  t = clamp(t, 0.0, 1.0);\r\n  return t * t * (3.0 - 2.0 * t);\r\n}\r\n\r\nvec4 maskColor() {\r\n  if (vMask <= 0.0) discard;\r\n  return vec4(vec3(1.0), ease(vMask));\r\n}\r\n",
"mesh.fragment.material": "#ifdef POSITION_STPQ\r\nvarying vec4 vSTPQ;\r\n#endif\r\n#ifdef POSITION_U\r\nvarying float vU;\r\n#endif\r\n#ifdef POSITION_UV\r\nvarying vec2 vUV;\r\n#endif\r\n#ifdef POSITION_UVW\r\nvarying vec3 vUVW;\r\n#endif\r\n#ifdef POSITION_UVWO\r\nvarying vec4 vUVWO;\r\n#endif\r\n\r\nvec4 getSample(vec4 rgba, vec4 stpq);\r\n\r\nvec4 getMaterialColor(vec4 rgba) {\r\n  vec4 stpq = vec4(0.0);\r\n\r\n  #ifdef POSITION_U\r\n  stpq.x = vU;\r\n  #endif\r\n  #ifdef POSITION_UV\r\n  stpq.xy = vUV;\r\n  #endif\r\n  #ifdef POSITION_UVW\r\n  stpq.xyz = vUVW;\r\n  #endif\r\n  #ifdef POSITION_UVWO\r\n  stpq = vUVWO;\r\n  #endif\r\n\r\n  #ifdef POSITION_STPQ\r\n  stpq = vSTPQ;\r\n  #endif\r\n\r\n  return getSample(rgba, stpq);\r\n}\r\n",
"mesh.fragment.shaded": "varying vec3 vNormal;\r\nvarying vec3 vLight;\r\nvarying vec3 vPosition;\r\n\r\nvec3 offSpecular(vec3 color) {\r\n  vec3 c = 1.0 - color;\r\n  return 1.0 - c * c;\r\n}\r\n\r\nvec4 getShadedColor(vec4 rgba) {\r\n  \r\n  vec3 color = rgba.xyz;\r\n  vec3 color2 = offSpecular(rgba.xyz);\r\n\r\n  vec3 normal = normalize(vNormal);\r\n  vec3 light = normalize(vLight);\r\n  vec3 position = normalize(vPosition);\r\n  \r\n  float side    = gl_FrontFacing ? -1.0 : 1.0;\r\n  float cosine  = side * dot(normal, light);\r\n  float diffuse = mix(max(0.0, cosine), .5 + .5 * cosine, .1);\r\n  \r\n  vec3  halfLight = normalize(light + position);\r\n\tfloat cosineHalf = max(0.0, side * dot(normal, halfLight));\r\n\tfloat specular = pow(cosineHalf, 16.0);\r\n\t\r\n\treturn vec4(color * (diffuse * .9 + .05) + .25 * color2 * specular, rgba.a);\r\n}\r\n",
"mesh.fragment.texture": "",
"mesh.gamma.in": "vec4 getGammaInColor(vec4 rgba) {\r\n  return vec4(rgba.rgb * rgba.rgb, rgba.a);\r\n}\r\n",
"mesh.gamma.out": "vec4 getGammaOutColor(vec4 rgba) {\r\n  return vec4(sqrt(rgba.rgb), rgba.a);\r\n}\r\n",
"mesh.map.uvwo": "vec4 mapUVWO(vec4 uvwo, vec4 stpq) {\r\n  return uvwo;\r\n}\r\n",
"mesh.position": "uniform vec4 geometryClip;\r\nattribute vec4 position4;\r\n\r\n// External\r\nvec3 getPosition(vec4 xyzw, float canonical);\r\n\r\nvec3 getMeshPosition() {\r\n  vec4 p = min(geometryClip, position4);\r\n  return getPosition(p, 1.0);\r\n}\r\n",
"mesh.vertex.color": "attribute vec4 position4;\r\nuniform vec4 geometryClip;\r\nvarying vec4 vColor;\r\n\r\n// External\r\nvec4 getSample(vec4 xyzw);\r\n\r\nvoid vertexColor() {\r\n  vec4 p = min(geometryClip, position4);\r\n  vColor = getSample(p);\r\n}\r\n",
"mesh.vertex.mask": "attribute vec4 position4;\r\nuniform vec4 geometryResolution;\r\nuniform vec4 geometryClip;\r\nvarying float vMask;\r\n\r\n// External\r\nfloat getSample(vec4 xyzw);\r\n\r\nvoid maskLevel() {\r\n  vec4 p = min(geometryClip, position4);\r\n  vMask = getSample(p * geometryResolution);\r\n}\r\n",
"mesh.vertex.position": "uniform vec4 geometryResolution;\r\n\r\n#ifdef POSITION_STPQ\r\nvarying vec4 vSTPQ;\r\n#endif\r\n#ifdef POSITION_U\r\nvarying float vU;\r\n#endif\r\n#ifdef POSITION_UV\r\nvarying vec2 vUV;\r\n#endif\r\n#ifdef POSITION_UVW\r\nvarying vec3 vUVW;\r\n#endif\r\n#ifdef POSITION_UVWO\r\nvarying vec4 vUVWO;\r\n#endif\r\n\r\n// External\r\nvec3 getPosition(vec4 xyzw, in vec4 stpqIn, out vec4 stpqOut);\r\n\r\nvec3 getMeshPosition(vec4 xyzw, float canonical) {\r\n  vec4 stpqOut, stpqIn = xyzw * geometryResolution;\r\n  vec3 xyz = getPosition(xyzw, stpqIn, stpqOut);\r\n\r\n  #ifdef POSITION_MAP\r\n  if (canonical > 0.5) {\r\n    #ifdef POSITION_STPQ\r\n    vSTPQ = stpqOut;\r\n    #endif\r\n    #ifdef POSITION_U\r\n    vU = stpqOut.x;\r\n    #endif\r\n    #ifdef POSITION_UV\r\n    vUV = stpqOut.xy;\r\n    #endif\r\n    #ifdef POSITION_UVW\r\n    vUVW = stpqOut.xyz;\r\n    #endif\r\n    #ifdef POSITION_UVWO\r\n    vUVWO = stpqOut;\r\n    #endif\r\n  }\r\n  #endif\r\n  return xyz;\r\n}\r\n",
"move.position": "uniform float transitionEnter;\r\nuniform float transitionExit;\r\nuniform vec4  transitionScale;\r\nuniform vec4  transitionBias;\r\nuniform float transitionSkew;\r\nuniform float transitionActive;\r\n\r\nuniform vec4  moveFrom;\r\nuniform vec4  moveTo;\r\n\r\nfloat ease(float t) {\r\n  t = clamp(t, 0.0, 1.0);\r\n  return 1.0 - (2.0 - t) * t;\r\n}\r\n\r\nvec4 getTransitionPosition(vec4 xyzw, inout vec4 stpq) {\r\n  if (transitionActive < 0.5) return xyzw;\r\n\r\n  float enter   = transitionEnter;\r\n  float exit    = transitionExit;\r\n  float skew    = transitionSkew;\r\n  vec4  scale   = transitionScale;\r\n  vec4  bias    = transitionBias;\r\n\r\n  float factor  = 1.0 + skew;\r\n  float offset  = dot(vec4(1.0), stpq * scale + bias);\r\n\r\n  float a1 = ease(enter * factor - offset);\r\n  float a2 = ease(exit  * factor + offset - skew);\r\n\r\n  return xyzw + a1 * moveFrom + a2 * moveTo;\r\n}",
"object.mask.default": "vec4 getMask(vec4 xyzw) {\r\n  return vec4(1.0);\r\n}",
"point.alpha.circle": "varying float vPixelSize;\r\n\r\nfloat getDiscAlpha(float mask) {\r\n  // Approximation: 1 - x*x is approximately linear around x = 1 with slope 2\r\n  return vPixelSize * (1.0 - mask);\r\n  //  return vPixelSize * 2.0 * (1.0 - sqrt(mask));\r\n}\r\n",
"point.alpha.circle.hollow": "varying float vPixelSize;\r\n\r\nfloat getDiscHollowAlpha(float mask) {\r\n  return vPixelSize * (0.5 - 2.0 * abs(sqrt(mask) - .75));\r\n}\r\n",
"point.alpha.generic": "varying float vPixelSize;\r\n\r\nfloat getGenericAlpha(float mask) {\r\n  return vPixelSize * 2.0 * (1.0 - mask);\r\n}\r\n",
"point.alpha.generic.hollow": "varying float vPixelSize;\r\n\r\nfloat getGenericHollowAlpha(float mask) {\r\n  return vPixelSize * (0.5 - 2.0 * abs(mask - .75));\r\n}\r\n",
"point.edge": "varying vec2 vSprite;\r\n\r\nfloat getSpriteMask(vec2 xy);\r\nfloat getSpriteAlpha(float mask);\r\n\r\nvoid setFragmentColorFill(vec4 color) {\r\n  float mask = getSpriteMask(vSprite);\r\n  if (mask > 1.0) {\r\n    discard;\r\n  }\r\n  float alpha = getSpriteAlpha(mask);\r\n  if (alpha >= 1.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor = vec4(color.rgb, alpha * color.a);\r\n}\r\n",
"point.fill": "varying vec2 vSprite;\r\n\r\nfloat getSpriteMask(vec2 xy);\r\nfloat getSpriteAlpha(float mask);\r\n\r\nvoid setFragmentColorFill(vec4 color) {\r\n  float mask = getSpriteMask(vSprite);\r\n  if (mask > 1.0) {\r\n    discard;\r\n  }\r\n  float alpha = getSpriteAlpha(mask);\r\n  if (alpha < 1.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor = color;\r\n}\r\n\r\n",
"point.mask.circle": "varying float vPixelSize;\r\n\r\nfloat getCircleMask(vec2 uv) {\r\n  return dot(uv, uv);\r\n}\r\n",
"point.mask.diamond": "varying float vPixelSize;\r\n\r\nfloat getDiamondMask(vec2 uv) {\r\n  vec2 a = abs(uv);\r\n  return a.x + a.y;\r\n}\r\n",
"point.mask.down": "varying float vPixelSize;\r\n\r\nfloat getTriangleDownMask(vec2 uv) {\r\n  uv.y += .25;\r\n  return max(uv.y, abs(uv.x) * .866 - uv.y * .5 + .6);\r\n}\r\n",
"point.mask.left": "varying float vPixelSize;\r\n\r\nfloat getTriangleLeftMask(vec2 uv) {\r\n  uv.x += .25;\r\n  return max(uv.x, abs(uv.y) * .866 - uv.x * .5 + .6);\r\n}\r\n",
"point.mask.right": "varying float vPixelSize;\r\n\r\nfloat getTriangleRightMask(vec2 uv) {\r\n  uv.x -= .25;\r\n  return max(-uv.x, abs(uv.y) * .866 + uv.x * .5 + .6);\r\n}\r\n",
"point.mask.square": "varying float vPixelSize;\r\n\r\nfloat getSquareMask(vec2 uv) {\r\n  vec2 a = abs(uv);\r\n  return max(a.x, a.y);\r\n}\r\n",
"point.mask.up": "varying float vPixelSize;\r\n\r\nfloat getTriangleUpMask(vec2 uv) {\r\n  uv.y -= .25;\r\n  return max(-uv.y, abs(uv.x) * .866 + uv.y * .5 + .6);\r\n}\r\n",
"point.position": "uniform float pointDepth;\r\n\r\nuniform float pixelUnit;\r\nuniform float renderScale;\r\nuniform float renderScaleInv;\r\nuniform float focusDepth;\r\n\r\nuniform vec4 geometryClip;\r\nattribute vec4 position4;\r\nattribute vec2 sprite;\r\n\r\nvarying vec2 vSprite;\r\nvarying float vPixelSize;\r\n\r\nconst float pointScale = POINT_SHAPE_SCALE;\r\n\r\n// External\r\nfloat getPointSize(vec4 xyzw);\r\nvec3 getPosition(vec4 xyzw, float canonical);\r\n\r\nvec3 getPointPosition() {\r\n  vec4 p = min(geometryClip, position4);\r\n  vec3 center = getPosition(p, 1.0);\r\n\r\n  // Depth blending\r\n  // TODO: orthographic camera\r\n  // Workaround: set depth = 0\r\n  float z = -center.z;\r\n  float depth = mix(z, focusDepth, pointDepth);\r\n  \r\n  // Match device/unit mapping \r\n  // Sprite goes from -1..1, width = 2.\r\n  float pointSize = getPointSize(p);\r\n  float size = pointScale * pointSize * pixelUnit * .5;\r\n  float depthSize = depth * size;\r\n  \r\n  // Pad sprite by half a pixel to make the anti-aliasing straddle the pixel edge\r\n  // Note: pixelsize measures radius\r\n  float pixelSize = .5 * (pointDepth > 0.0 ? depthSize / z : size);\r\n  float paddedSize = pixelSize + 0.5;\r\n  float padFactor = paddedSize / pixelSize;\r\n\r\n  vPixelSize = paddedSize;\r\n  vSprite    = sprite;\r\n\r\n  return center + vec3(sprite * depthSize * renderScaleInv * padFactor, 0.0);\r\n}\r\n",
"point.size.uniform": "uniform float pointSize;\r\n\r\nfloat getPointSize(vec4 xyzw) {\r\n  return pointSize;\r\n}",
"point.size.varying": "uniform float pointSize;\r\n\r\nvec4 getSample(vec4 xyzw);\r\n\r\nfloat getPointSize(vec4 xyzw) {\r\n  return pointSize * getSample(xyzw).x;\r\n}",
"polar.position": "uniform float polarBend;\r\nuniform float polarFocus;\r\nuniform float polarAspect;\r\nuniform float polarHelix;\r\n\r\nuniform mat4 viewMatrix;\r\n\r\nvec4 getPolarPosition(vec4 position, inout vec4 stpq) {\r\n  if (polarBend > 0.0) {\r\n\r\n    if (polarBend < 0.001) {\r\n      // Factor out large addition/subtraction of polarFocus\r\n      // to avoid numerical error\r\n      // sin(x) ~ x\r\n      // cos(x) ~ 1 - x * x / 2\r\n      vec2 pb = position.xy * polarBend;\r\n      float ppbbx = pb.x * pb.x;\r\n      return viewMatrix * vec4(\r\n        position.x * (1.0 - polarBend + (pb.y * polarAspect)),\r\n        position.y * (1.0 - .5 * ppbbx) - (.5 * ppbbx) * polarFocus / polarAspect,\r\n        position.z + position.x * polarHelix * polarBend,\r\n        1.0\r\n      );\r\n    }\r\n    else {\r\n      vec2 xy = position.xy * vec2(polarBend, polarAspect);\r\n      float radius = polarFocus + xy.y;\r\n      return viewMatrix * vec4(\r\n        sin(xy.x) * radius,\r\n        (cos(xy.x) * radius - polarFocus) / polarAspect,\r\n        position.z + position.x * polarHelix * polarBend,\r\n        1.0\r\n      );\r\n    }\r\n  }\r\n  else {\r\n    return viewMatrix * vec4(position.xyz, 1.0);\r\n  }\r\n}",
"project.position": "uniform float styleZBias;\r\nuniform float styleZIndex;\r\n\r\nvoid setPosition(vec3 position) {\r\n  vec4 pos = projectionMatrix * vec4(position, 1.0);\r\n\r\n  // Apply relative Z bias\r\n  float bias  = (1.0 - styleZBias / 32768.0);\r\n  pos.z *= bias;\r\n  \r\n  // Apply large scale Z index changes\r\n  if (styleZIndex > 0.0) {\r\n    float z = pos.z / pos.w;\r\n    pos.z = ((z + 1.0) / (styleZIndex + 1.0) - 1.0) * pos.w;\r\n  }\r\n  \r\n  gl_Position = pos;\r\n}",
"project.readback": "// This is three.js' global uniform, missing from fragment shaders.\r\nuniform mat4 projectionMatrix;\r\n\r\nvec4 readbackPosition(vec3 position, vec4 stpq) {\r\n  vec4 pos = projectionMatrix * vec4(position, 1.0);\r\n  vec3 final = pos.xyz / pos.w;\r\n  if (final.z < -1.0) {\r\n    return vec4(0.0, 0.0, 0.0, -1.0);\r\n  }\r\n  else {\r\n    return vec4(final, -position.z);\r\n  }\r\n}\r\n",
"raw.position.scale": "uniform vec4 geometryScale;\r\nattribute vec4 position4;\r\n\r\nvec4 getRawPositionScale() {\r\n  return geometryScale * position4;\r\n}\r\n",
"repeat.position": "uniform vec4 repeatModulus;\r\n\r\nvec4 getRepeatXYZW(vec4 xyzw) {\r\n  return mod(xyzw + .5, repeatModulus) - .5;\r\n}\r\n",
"resample.padding": "uniform vec4 resampleBias;\r\n\r\nvec4 resamplePadding(vec4 xyzw) {\r\n  return xyzw + resampleBias;\r\n}",
"resample.relative": "uniform vec4 resampleFactor;\r\n\r\nvec4 resampleRelative(vec4 xyzw) {\r\n  return xyzw * resampleFactor;\r\n}",
"reveal.mask": "uniform float transitionEnter;\r\nuniform float transitionExit;\r\nuniform vec4  transitionScale;\r\nuniform vec4  transitionBias;\r\nuniform float transitionSkew;\r\nuniform float transitionActive;\r\n\r\nfloat getTransitionSDFMask(vec4 stpq) {\r\n  if (transitionActive < 0.5) return 1.0;\r\n\r\n  float enter   = transitionEnter;\r\n  float exit    = transitionExit;\r\n  float skew    = transitionSkew;\r\n  vec4  scale   = transitionScale;\r\n  vec4  bias    = transitionBias;\r\n\r\n  float factor  = 1.0 + skew;\r\n  float offset  = dot(vec4(1.0), stpq * scale + bias);\r\n\r\n  vec2 d = vec2(enter, exit) * factor + vec2(-offset, offset - skew);\r\n  if (exit  == 1.0) return d.x;\r\n  if (enter == 1.0) return d.y;\r\n  return min(d.x, d.y);\r\n}",
"root.position": "vec3 getRootPosition(vec4 position, in vec4 stpqIn, out vec4 stpqOut) {\r\n  stpqOut = stpqIn; // avoid inout confusion\r\n  return position.xyz;\r\n}",
"sample.2d": "uniform sampler2D dataTexture;\r\n\r\nvec4 sample2D(vec2 uv) {\r\n  return texture2D(dataTexture, uv);\r\n}\r\n",
"scale.position": "uniform vec4 scaleAxis;\r\nuniform vec4 scaleOffset;\r\n\r\nvec4 sampleData(float x);\r\n\r\nvec4 getScalePosition(vec4 xyzw) {\r\n  return scaleAxis * sampleData(xyzw.x).x + scaleOffset;\r\n}\r\n",
"screen.map.stpq": "uniform vec4 remapSTPQScale;\r\n\r\nvec4 screenMapSTPQ(vec4 xyzw, out vec4 stpq) {\r\n  stpq = xyzw * remapSTPQScale;\r\n  return xyzw;\r\n}\r\n",
"screen.map.xy": "uniform vec2 remapUVScale;\r\n\r\nvec4 screenMapXY(vec4 uvwo, vec4 stpq) {\r\n  return vec4(floor(remapUVScale * uvwo.xy), 0.0, 0.0);\r\n}\r\n",
"screen.map.xyzw": "uniform vec2 remapUVScale;\r\nuniform vec2 remapModulus;\r\nuniform vec2 remapModulusInv;\r\n\r\nvec4 screenMapXYZW(vec4 uvwo, vec4 stpq) {\r\n  vec2 st = floor(remapUVScale * uvwo.xy);\r\n  vec2 xy = st * remapModulusInv;\r\n  vec2 ixy = floor(xy);\r\n  vec2 fxy = xy - ixy;\r\n  vec2 zw = fxy * remapModulus;\r\n  return vec4(ixy.x, zw.y, ixy.y, zw.x);\r\n}\r\n",
"screen.pass.uv": "vec2 screenPassUV(vec4 uvwo, vec4 stpq) {\r\n  return uvwo.xy;\r\n}\r\n",
"screen.position": "void setScreenPosition(vec4 position) {\r\n  gl_Position = vec4(position.xy * 2.0 - 1.0, 0.5, 1.0);\r\n}\r\n",
"slice.position": "uniform vec4 sliceOffset;\r\n\r\nvec4 getSliceOffset(vec4 xyzw) {\r\n  return xyzw + sliceOffset;\r\n}\r\n",
"spherical.position": "uniform float sphericalBend;\r\nuniform float sphericalFocus;\r\nuniform float sphericalAspectX;\r\nuniform float sphericalAspectY;\r\nuniform float sphericalScaleY;\r\n\r\nuniform mat4 viewMatrix;\r\n\r\nvec4 getSphericalPosition(vec4 position, inout vec4 stpq) {\r\n  if (sphericalBend > 0.0001) {\r\n\r\n    vec3 xyz = position.xyz * vec3(sphericalBend, sphericalBend / sphericalAspectY * sphericalScaleY, sphericalAspectX);\r\n    float radius = sphericalFocus + xyz.z;\r\n    float cosine = cos(xyz.y) * radius;\r\n\r\n    return viewMatrix * vec4(\r\n      sin(xyz.x) * cosine,\r\n      sin(xyz.y) * radius * sphericalAspectY,\r\n      (cos(xyz.x) * cosine - sphericalFocus) / sphericalAspectX,\r\n      1.0\r\n    );\r\n  }\r\n  else {\r\n    return viewMatrix * vec4(position.xyz, 1.0);\r\n  }\r\n}",
"split.position": "uniform float splitStride;\r\n\r\nvec2 getIndices(vec4 xyzw);\r\nvec4 getRest(vec4 xyzw);\r\nvec4 injectIndex(float v);\r\n\r\nvec4 getSplitXYZW(vec4 xyzw) {\r\n  vec2 uv = getIndices(xyzw);\r\n  float offset = uv.x + uv.y * splitStride;\r\n  return injectIndex(offset) + getRest(xyzw);\r\n}\r\n",
"spread.position": "uniform vec4 spreadOffset;\r\nuniform mat4 spreadMatrix;\r\n\r\n// External\r\nvec4 getSample(vec4 xyzw);\r\n\r\nvec4 getSpreadSample(vec4 xyzw) {\r\n  vec4 sample = getSample(xyzw);\r\n  return sample + spreadMatrix * (spreadOffset + xyzw);\r\n}\r\n",
"sprite.fragment": "varying vec2 vSprite;\r\n\r\nvec4 getSample(vec2 xy);\r\n\r\nvec4 getSpriteColor() {\r\n  return getSample(vSprite);\r\n}",
"sprite.position": "uniform vec2 spriteOffset;\r\nuniform float spriteScale;\r\nuniform float spriteDepth;\r\nuniform float spriteSnap;\r\n\r\nuniform vec2 renderOdd;\r\nuniform float renderScale;\r\nuniform float renderScaleInv;\r\nuniform float pixelUnit;\r\nuniform float focusDepth;\r\n\r\nuniform vec4 geometryClip;\r\nattribute vec4 position4;\r\nattribute vec2 sprite;\r\n\r\nvarying float vPixelSize;\r\n\r\n// External\r\nvec3 getPosition(vec4 xyzw, float canonical);\r\nvec4 getSprite(vec4 xyzw);\r\n\r\nvec3 getSpritePosition() {\r\n  // Clip points\r\n  vec4 p = min(geometryClip, position4);\r\n  float diff = length(position4 - p);\r\n  if (diff > 0.0) {\r\n    return vec3(0.0, 0.0, 1000.0);\r\n  }\r\n\r\n  // Make sprites\r\n  vec3 center = getPosition(p, 1.0);\r\n  vec4 atlas = getSprite(p);\r\n\r\n  // Sprite goes from -1..1, width = 2.\r\n  // -1..1 -> -0.5..0.5\r\n  vec2 halfSprite = sprite * .5;\r\n  vec2 halfFlipSprite = vec2(halfSprite.x, -halfSprite.y);\r\n\r\n#ifdef POSITION_UV\r\n  // Assign UVs\r\n  vUV = atlas.xy + atlas.zw * (halfFlipSprite + .5);\r\n#endif\r\n\r\n  // Depth blending\r\n  // TODO: orthographic camera\r\n  // Workaround: set depth = 0\r\n  float depth = focusDepth, z;\r\n  z = -center.z;\r\n  if (spriteDepth < 1.0) {\r\n    depth = mix(z, focusDepth, spriteDepth);\r\n  }\r\n  \r\n  // Match device/unit mapping \r\n  float size = pixelUnit * spriteScale;\r\n  float depthSize = depth * size;\r\n\r\n  // Calculate pixelSize for anti-aliasing\r\n  float pixelSize = (spriteDepth > 0.0 ? depthSize / z : size);\r\n  vPixelSize = pixelSize;\r\n\r\n  // Position sprite\r\n  vec2 atlasOdd = fract(atlas.zw / 2.0);\r\n  vec2 offset = (spriteOffset + halfSprite * atlas.zw) * depthSize;\r\n  if (spriteSnap > 0.5) {\r\n    // Snap to pixel (w/ epsilon shift to avoid jitter)\r\n    return vec3(((floor(center.xy / center.z * renderScale + 0.001) + renderOdd + atlasOdd) * center.z + offset) * renderScaleInv, center.z);\r\n  }\r\n  else {\r\n    // Place directly\r\n    return center + vec3(offset * renderScaleInv, 0.0);\r\n  }\r\n\r\n}\r\n",
"stereographic.position": "uniform float stereoBend;\r\n\r\nuniform mat4 viewMatrix;\r\n\r\nvec4 getStereoPosition(vec4 position, inout vec4 stpq) {\r\n  if (stereoBend > 0.0001) {\r\n\r\n    vec3 pos = position.xyz;\r\n    float r = length(pos);\r\n    float z = r + pos.z;\r\n    vec3 project = vec3(pos.xy / z, r);\r\n    \r\n    vec3 lerped = mix(pos, project, stereoBend);\r\n\r\n    return viewMatrix * vec4(lerped, 1.0);\r\n  }\r\n  else {\r\n    return viewMatrix * vec4(position.xyz, 1.0);\r\n  }\r\n}",
"stereographic4.position": "uniform float stereoBend;\r\nuniform vec4 basisScale;\r\nuniform vec4 basisOffset;\r\nuniform mat4 viewMatrix;\r\nuniform vec2 view4D;\r\n\r\nvec4 getStereographic4Position(vec4 position, inout vec4 stpq) {\r\n  \r\n  vec4 transformed;\r\n  if (stereoBend > 0.0001) {\r\n\r\n    float r = length(position);\r\n    float w = r + position.w;\r\n    vec4 project = vec4(position.xyz / w, r);\r\n    \r\n    transformed = mix(position, project, stereoBend);\r\n  }\r\n  else {\r\n    transformed = position;\r\n  }\r\n\r\n  vec4 pos4 = transformed * basisScale - basisOffset;\r\n  vec3 xyz = (viewMatrix * vec4(pos4.xyz, 1.0)).xyz;\r\n  return vec4(xyz, pos4.w * view4D.y + view4D.x);\r\n}\r\n",
"stpq.sample.2d": "varying vec2 vST;\r\n\r\nvec4 getSample(vec2 st);\r\n\r\nvec4 getSTSample() {\r\n  return getSample(vST);\r\n}\r\n",
"stpq.xyzw.2d": "varying vec2 vUV;\r\n\r\nvoid setRawUV(vec4 xyzw) {\r\n  vUV = xyzw.xy;\r\n}\r\n",
"strip.position.normal": "uniform vec4 geometryClip;\r\nattribute vec4 position4;\r\nattribute vec3 strip;\r\n\r\n// External\r\nvec3 getPosition(vec4 xyzw, float canonical);\r\n\r\nvarying vec3 vNormal;\r\nvarying vec3 vLight;\r\nvarying vec3 vPosition;\r\n\r\nvoid getStripGeometry(vec4 xyzw, vec3 strip, out vec3 pos, out vec3 normal) {\r\n  vec3 a, b, c;\r\n\r\n  a   = getPosition(xyzw, 1.0);\r\n  b   = getPosition(vec4(xyzw.xyz, strip.x), 0.0);\r\n  c   = getPosition(vec4(xyzw.xyz, strip.y), 0.0);\r\n\r\n  normal = normalize(cross(c - a, b - a)) * strip.z;\r\n  \r\n  pos = a;\r\n}\r\n\r\nvec3 getStripPositionNormal() {\r\n  vec3 center, normal;\r\n\r\n  vec4 p = min(geometryClip, position4);\r\n\r\n  getStripGeometry(p, strip, center, normal);\r\n  vNormal   = normal;\r\n  vLight    = normalize((viewMatrix * vec4(1.0, 2.0, 2.0, 0.0)).xyz);\r\n  vPosition = -center;\r\n\r\n  return center;\r\n}\r\n",
"style.color": "uniform vec3 styleColor;\r\nuniform float styleOpacity;\r\n\r\nvec4 getStyleColor() {\r\n  return vec4(styleColor, styleOpacity);\r\n}\r\n",
"subdivide.depth": "uniform float subdivideBevel;\r\n\r\n// External\r\nvec4 sampleData(vec4 xyzw);\r\n\r\nvec4 subdivideDepth(vec4 xyzw) {\r\n  float x = xyzw.z;\r\n  float i = floor(x);\r\n  float f = x - i;\r\n\r\n  float minf = subdivideBevel * min(f, 1.0 - f);\r\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\r\n\r\n  return sampleData(vec4(xyzw.xy, i + g, xyzw.w));\r\n}\r\n",
"subdivide.depth.lerp": "uniform float subdivideBevel;\r\n\r\n// External\r\nvec4 sampleData(vec4 xyzw);\r\n\r\nvec4 subdivideDepthLerp(vec4 xyzw) {\r\n  float x = xyzw.z;\r\n  float i = floor(x);\r\n  float f = x - i;\r\n\r\n  float minf = subdivideBevel * min(f, 1.0 - f);\r\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\r\n\r\n  vec4 xyzw1 = vec4(xyzw.xy, i, xyzw.w);\r\n  vec4 xyzw2 = vec4(xyzw.xy, i + 1.0, xyzw.w);\r\n  \r\n  vec4 a = sampleData(xyzw1);\r\n  vec4 b = sampleData(xyzw2);\r\n\r\n  return mix(a, b, g);\r\n}\r\n",
"subdivide.height": "uniform float subdivideBevel;\r\n\r\n// External\r\nvec4 sampleData(vec4 xyzw);\r\n\r\nvec4 subdivideHeight(vec4 xyzw) {\r\n  float x = xyzw.y;\r\n  float i = floor(x);\r\n  float f = x - i;\r\n\r\n  float minf = subdivideBevel * min(f, 1.0 - f);\r\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\r\n\r\n  return sampleData(vec4(xyzw.x, i + g, xyzw.zw));\r\n}\r\n",
"subdivide.height.lerp": "uniform float subdivideBevel;\r\n\r\n// External\r\nvec4 sampleData(vec4 xyzw);\r\n\r\nvec4 subdivideHeightLerp(vec4 xyzw) {\r\n  float x = xyzw.y;\r\n  float i = floor(x);\r\n  float f = x - i;\r\n\r\n  float minf = subdivideBevel * min(f, 1.0 - f);\r\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\r\n\r\n  vec4 xyzw1 = vec4(xyzw.x, i, xyzw.zw);\r\n  vec4 xyzw2 = vec4(xyzw.x, i + 1.0, xyzw.zw);\r\n  \r\n  vec4 a = sampleData(xyzw1);\r\n  vec4 b = sampleData(xyzw2);\r\n\r\n  return mix(a, b, g);\r\n}\r\n",
"subdivide.items": "uniform float subdivideBevel;\r\n\r\n// External\r\nvec4 sampleData(vec4 xyzw);\r\n\r\nvec4 subdivideItems(vec4 xyzw) {\r\n  float x = xyzw.w;\r\n  float i = floor(x);\r\n  float f = x - i;\r\n\r\n  float minf = subdivideBevel * min(f, 1.0 - f);\r\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\r\n\r\n  return sampleData(vec4(xyzw.xyz, i + g));\r\n}\r\n",
"subdivide.items.lerp": "uniform float subdivideBevel;\r\n\r\n// External\r\nvec4 sampleData(vec4 xyzw);\r\n\r\nvec4 subdivideItemsLerp(vec4 xyzw) {\r\n  float x = xyzw.w;\r\n  float i = floor(x);\r\n  float f = x - i;\r\n\r\n  float minf = subdivideBevel * min(f, 1.0 - f);\r\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\r\n\r\n  vec4 xyzw1 = vec4(xyzw.xyz, i);\r\n  vec4 xyzw2 = vec4(xyzw.xyz, i + 1.0);\r\n  \r\n  vec4 a = sampleData(xyzw1);\r\n  vec4 b = sampleData(xyzw2);\r\n\r\n  return mix(a, b, g);\r\n}\r\n",
"subdivide.width": "uniform float subdivideBevel;\r\n\r\n// External\r\nvec4 sampleData(vec4 xyzw);\r\n\r\nvec4 subdivideWidth(vec4 xyzw) {\r\n  float x = xyzw.x;\r\n  float i = floor(x);\r\n  float f = x - i;\r\n\r\n  float minf = subdivideBevel * min(f, 1.0 - f);\r\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\r\n\r\n  return sampleData(vec4(i + g, xyzw.yzw));\r\n}\r\n",
"subdivide.width.lerp": "uniform float subdivideBevel;\r\n\r\n// External\r\nvec4 sampleData(vec4 xyzw);\r\n\r\nvec4 subdivideWidthLerp(vec4 xyzw) {\r\n  float x = xyzw.x;\r\n  float i = floor(x);\r\n  float f = x - i;\r\n\r\n  float minf = subdivideBevel * min(f, 1.0 - f);\r\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\r\n\r\n  vec4 xyzw1 = vec4(i, xyzw.yzw);\r\n  vec4 xyzw2 = vec4(i + 1.0, xyzw.yzw);\r\n  \r\n  vec4 a = sampleData(xyzw1);\r\n  vec4 b = sampleData(xyzw2);\r\n\r\n  return mix(a, b, g);\r\n}\r\n",
"surface.mask.hollow": "attribute vec4 position4;\r\n\r\nfloat getSurfaceHollowMask(vec4 xyzw) {\r\n  vec4 df = abs(fract(position4) - .5);\r\n  vec2 df2 = min(df.xy, df.zw);\r\n  float df3 = min(df2.x, df2.y);\r\n  return df3;\r\n}",
"surface.position": "uniform vec4 geometryClip;\r\nuniform vec4 geometryResolution;\r\nuniform vec4 mapSize;\r\n\r\nattribute vec4 position4;\r\n\r\n// External\r\nvec3 getPosition(vec4 xyzw, float canonical);\r\n\r\nvec3 getSurfacePosition() {\r\n  vec4 p = min(geometryClip, position4);\r\n  vec3 xyz = getPosition(p, 1.0);\r\n\r\n  // Overwrite UVs\r\n#ifdef POSITION_UV\r\n#ifdef POSITION_UV_INT\r\n  vUV = -.5 + (position4.xy * geometryResolution.xy) * mapSize.xy;\r\n#else\r\n  vUV = position4.xy * geometryResolution.xy;\r\n#endif\r\n#endif\r\n\r\n  return xyz;\r\n}\r\n",
"surface.position.normal": "uniform vec4 mapSize;\r\nuniform vec4 geometryResolution;\r\nuniform vec4 geometryClip;\r\nattribute vec4 position4;\r\nattribute vec2 surface;\r\n\r\n// External\r\nvec3 getPosition(vec4 xyzw, float canonical);\r\n\r\nvoid getSurfaceGeometry(vec4 xyzw, float edgeX, float edgeY, out vec3 left, out vec3 center, out vec3 right, out vec3 up, out vec3 down) {\r\n  vec4 deltaX = vec4(1.0, 0.0, 0.0, 0.0);\r\n  vec4 deltaY = vec4(0.0, 1.0, 0.0, 0.0);\r\n\r\n  /*\r\n  // high quality, 5 tap\r\n  center =                  getPosition(xyzw, 1.0);\r\n  left   = (edgeX > -0.5) ? getPosition(xyzw - deltaX, 0.0) : center;\r\n  right  = (edgeX < 0.5)  ? getPosition(xyzw + deltaX, 0.0) : center;\r\n  down   = (edgeY > -0.5) ? getPosition(xyzw - deltaY, 0.0) : center;\r\n  up     = (edgeY < 0.5)  ? getPosition(xyzw + deltaY, 0.0) : center;\r\n  */\r\n  \r\n  // low quality, 3 tap\r\n  center =                  getPosition(xyzw, 1.0);\r\n  left   =                  center;\r\n  down   =                  center;\r\n  right  = (edgeX < 0.5)  ? getPosition(xyzw + deltaX, 0.0) : (2.0 * center - getPosition(xyzw - deltaX, 0.0));\r\n  up     = (edgeY < 0.5)  ? getPosition(xyzw + deltaY, 0.0) : (2.0 * center - getPosition(xyzw - deltaY, 0.0));\r\n}\r\n\r\nvec3 getSurfaceNormal(vec3 left, vec3 center, vec3 right, vec3 up, vec3 down) {\r\n  vec3 dx = right - left;\r\n  vec3 dy = up    - down;\r\n  vec3 n = cross(dy, dx);\r\n  if (length(n) > 0.0) {\r\n    return normalize(n);\r\n  }\r\n  return vec3(0.0, 1.0, 0.0);\r\n}\r\n\r\nvarying vec3 vNormal;\r\nvarying vec3 vLight;\r\nvarying vec3 vPosition;\r\n\r\nvec3 getSurfacePositionNormal() {\r\n  vec3 left, center, right, up, down;\r\n\r\n  vec4 p = min(geometryClip, position4);\r\n\r\n  getSurfaceGeometry(p, surface.x, surface.y, left, center, right, up, down);\r\n  vNormal   = getSurfaceNormal(left, center, right, up, down);\r\n  vLight    = normalize((viewMatrix * vec4(1.0, 2.0, 2.0, 0.0)).xyz); // hardcoded directional light\r\n  vPosition = -center;\r\n\r\n#ifdef POSITION_UV\r\n#ifdef POSITION_UV_INT\r\n  vUV = -.5 + (position4.xy * geometryResolution.xy) * mapSize.xy;\r\n#else\r\n  vUV = position4.xy * geometryResolution.xy;\r\n#endif\r\n#endif\r\n  \r\n  return center;\r\n}\r\n",
"ticks.position": "uniform float worldUnit;\r\nuniform float focusDepth;\r\nuniform float tickSize;\r\nuniform float tickEpsilon;\r\nuniform vec3  tickNormal;\r\nuniform vec2  tickStrip;\r\n\r\nvec4 getSample(vec4 xyzw);\r\n\r\nvec3 transformPosition(vec4 position, in vec4 stpqIn, out vec4 stpqOut);\r\n\r\nvec3 getTickPosition(vec4 xyzw, in vec4 stpqIn, out vec4 stpqOut) {\r\n  float epsilon = tickEpsilon;\r\n\r\n  // determine tick direction\r\n  float leftX  = max(tickStrip.x, xyzw.y - 1.0);\r\n  float rightX = min(tickStrip.y, xyzw.y + 1.0);\r\n  \r\n  vec4 left    = getSample(vec4(leftX,  xyzw.zw, 0.0));\r\n  vec4 right   = getSample(vec4(rightX, xyzw.zw, 0.0));\r\n  vec4 diff    = right - left;\r\n\r\n  vec3 normal  = cross(normalize(diff.xyz + vec3(diff.w)), tickNormal);\r\n  float bias   = max(0.0, 1.0 - length(normal) * 2.0);\r\n       normal  = mix(normal, tickNormal.yzx, bias * bias);\r\n  \r\n  // transform (point) and (point + delta)\r\n  vec4 center  = getSample(vec4(xyzw.yzw, 0.0));\r\n  vec4 delta   = vec4(normal, 0.0) * epsilon;\r\n\r\n  vec4 a = center;\r\n  vec4 b = center + delta;\r\n\r\n  vec4 _;\r\n  vec3 c = transformPosition(a, stpqIn, stpqOut);\r\n  vec3 d = transformPosition(b, stpqIn, _);\r\n  \r\n  // sample on either side to create line\r\n  float line = xyzw.x - .5;\r\n  vec3  mid  = c;\r\n  vec3  side = normalize(d - c);\r\n\r\n  return mid + side * line * tickSize * worldUnit * focusDepth;\r\n}\r\n",
"transform3.position": "uniform mat4 transformMatrix;\r\n\r\nvec4 transformPosition(vec4 position, inout vec4 stpq) {\r\n  return transformMatrix * vec4(position.xyz, 1.0);\r\n}\r\n",
"transform4.position": "uniform mat4 transformMatrix;\r\nuniform vec4 transformOffset;\r\n\r\nvec4 transformPosition(vec4 position, inout vec4 stpq) {\r\n  return transformMatrix * position + transformOffset;\r\n}\r\n",
"view.position": "// Implicit three.js uniform\r\n// uniform mat4 viewMatrix;\r\n\r\nvec4 getViewPosition(vec4 position, inout vec4 stpq) {\r\n  return (viewMatrix * vec4(position.xyz, 1.0));\r\n}\r\n"};
